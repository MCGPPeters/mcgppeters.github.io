# The (non) sense of (micro) services : the composition of software in different levels of granularity

Recently I listened to another interesting episode of .NET Rocks, this time with guest Juval Lowy, about [“The evolution of services”](http://www.dotnetrocks.com/?show=1293). As a consequence there was some discussion in the show comments about what micro services actually are and what added value the principle of “every class as a service” could have (among other subjects).

I had a nice discussion with Mark Seemann and this post summarizes my thoughts I expressed there, for my own recollection and for continuing an open exchange of viewpoints on the topics. As analogy to explain my thoughts on the subjects, I use music….

Lets suppose we have a genius composer like Bach. To be able to express his creativity he had only a number of concepts available to him (and I am of course simplifying) : different notes. A's , B's, C#, F# (pun intended) etc... These notes had a well defined meaning to him. He knew how to arrange these notes in endless variations to create musical masterpieces. Without knowing (assuming he wasn't a physicist) or at least needing to know how the sound of a note is actually produced (pitch, vibration, instrument), he did know what to do with them to create a design, a composition.

The notes in this analogy can be seen as (micro) services in my view in the context of composing music. They have just enough granularity in the functionality that they expose to have meaning to the composer and simultaneously enable him to arrange them in countless ways without having him to know how the functionality is actually produced. So the adjective 'micro' is in my opinion superfluous because there is no prescription that says how 'big' the services ought to be ("size is not important... it is what...." ehm... well I will stop that analogy here)... Mind services are only regarded as such by the ones who know how to use them and to whom they provide value. They are experts (or at least knowledgeable) within the domain / context where the services are exposed. These experts can be organic or silicon based machines / entities…

The compositions by Bach are designs in this analogy... The musical notes (services) form building blocks in an architecture... And software is all about composition... at different levels of granularity. Taking small parts and binding them together with a set of well defined rules to create complex behavior. Whether they are at the granular level of services, functions or other kinds collections of behavior.

Bach can be seen as a business architect.... He arranges a set of well defined building blocks in multiple, different, but very meaningful manners. In business, one can create a competitive advantage by being creative and innovative in arranging the way you do business... This kind of architecture can help with this.

The role for the programmer, and arguably the challenging part for him, is to make that note do what it should do when it is asked to provide its service ("give me an A please", or in a reactive model, "the musician touched the A string => ok.. I will give you the sound you asked for in the pitch etc.. that I know to provide") .... He knows how the note should provide its service and encodes this.

Agile teams come together to compose the services into features according to a design. Agile teams are multidisciplinary.. so a business architect and programmers, that know how to connect the services to implement the feature, are example members...

I would argue that what the general community means with a micro service is probably a service that has a meaning within a specialist certain business context. One or more of these specialists, lets call them business architects for kicks, are the people within a business that are able to compose these building blocks into designs that can provide a service (and associated value) to their customers. These could be internal or external customers. These are the services that can provide a competitive advantage to the business. Designing, building and maintaining these kinds of services and composing these into systems is very cost intensive and in my opinion should only be done while building systems that actually give a competitive advantage.

On the more technical side of the conversation, a service does not mean it communicates with the outside would using HTTP (or protocol layered on top of that). Communication between micro services will most probably be based on using HTTP since it is the communications protocol that has the highest guarantee of being interoperable and a lot of purpose built infrastructure is in place to accommodate it. It is currently the most suitable protocol for this purpose.

However when it comes to the more granular services Juval Lowy is talking about (“every class is a service”) that are used to implement the micro services themselves, they will most probably be actors. By services in this context I think Juval means components that communicate via asynchronous message passing. Actors are one example of this. Micro services could be build according to the actor model of computation as well by composing more granular actors. The protocol actors / services use to exchange messages can vary. A protocol does not by definition mean a network protocol. A protocol just means communicating in a manner that is well defined and can / must be understood by all participating parties. Protocols can be layered as we know... So services / actors exchange well defined messages, maybe on top of a network protocol like HTTP.... But it would not be efficient to use HTTP while communicating between services when they run in the same process. They will / should not use a network protocol at al. They can pass messages directly in memory. The actor model enables building systems in this fashion.

In the podcast Juval mentions it is the role of a “fabric” to determine which protocol is most suitable to transfer a message from one service to another. Again the actor model enables this. This fabric is nothing more than a kind of distributed .NET runtime for actor systems, providing capabilities like garbage collection and finding the physical address of an actor to route a message to, whether it be a local memory address or an URI of a node within the fabric on which the target actor resides.

Probably more on the subject in the near future … please share you opinions and viewpoints on the subject….